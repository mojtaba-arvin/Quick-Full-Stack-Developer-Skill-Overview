### Object-Oriented Programming (OOP) Basics:
- **Objects:** Model real-world entities or concepts as objects in code, encapsulating data and behavior together into cohesive units with attributes and methods.
- **Classes:** Define blueprints or templates for creating objects with shared characteristics and behavior, encapsulating data structures and methods within a class definition.
- **Abstraction:** Abstract common features and behaviors from concrete objects into abstract classes or interfaces, promoting code reuse, modularity, and extensibility.
- **Encapsulation:** Encapsulate data within objects and restrict access to internal data and implementation details using access modifiers (e.g., public, private, protected) for data hiding and information hiding.
- **Inheritance:** Establish hierarchical relationships between classes by inheriting attributes and behaviors from parent classes (superclasses) to child classes (subclasses) to promote code reuse and specialization.
- **Polymorphism:** Enable objects to exhibit multiple forms or behaviors through polymorphic methods, interfaces, or inheritance, allowing different objects to respond differently to the same message or method invocation.

### Classes and Objects:
- **Class Definition:** Define classes in object-oriented languages (e.g., Python, Java, C++) using class declarations, constructors, instance variables, and methods to represent abstract data types and define object behaviors.
- **Object Instantiation:** Instantiate objects from class definitions by invoking constructors or factory methods to create object instances with unique state and identity.
- **Instance Variables:** Declare instance variables within class definitions to store object state and attributes, encapsulating object data within individual instances.
- **Methods:** Define methods within class definitions to encapsulate object behaviors, operations, and actions, allowing objects to interact with each other and manipulate their internal state.

### Inheritance and Composition:
- **Single Inheritance:** Implement single inheritance relationships between classes, where child classes inherit attributes and behaviors from a single parent class to promote code reuse and specialization.
- **Multiple Inheritance:** Support multiple inheritance relationships between classes, where child classes inherit attributes and behaviors from multiple parent classes, combining features from different sources.
- **Composition:** Compose objects by embedding or containing instances of other classes within a class definition, promoting object composition over inheritance and enabling flexible object structures and relationships.

### Polymorphism and Method Overriding:
- **Method Overriding:** Override methods in subclass definitions to provide specialized implementations or behaviors, replacing or extending inherited method functionality while preserving the method signature and interface.
- **Dynamic Binding:** Support dynamic method binding and runtime polymorphism, where method calls are resolved at runtime based on the actual type or class of the object, enabling late binding and runtime dispatch.

### Encapsulation and Access Control:
- **Access Modifiers:** Enforce access control and visibility restrictions on class members (variables, methods) using access modifiers (e.g., public, private, protected) to define data encapsulation and information hiding rules.
- **Getter and Setter Methods:** Provide getter and setter methods within class definitions to encapsulate access to private instance variables, enabling controlled access and manipulation of object state.

### Abstract Classes and Interfaces:
- **Abstract Classes:** Define abstract classes with abstract methods and concrete methods to represent incomplete or partial implementations, serving as blueprints for concrete subclasses to implement.
- **Interfaces:** Declare interfaces as contracts or specifications for classes to implement, defining method signatures and behaviors without specifying implementation details, enabling multiple inheritance and interface-based programming.

### Design Patterns:
- **Creational Patterns:** Utilize creational design patterns (e.g., Factory Method, Singleton, Builder) to abstract object creation mechanisms, manage object lifecycles, and decouple object creation from object usage.
- **Structural Patterns:** Apply structural design patterns (e.g., Adapter, Decorator, Composite) to compose objects into larger structures, manage object relationships, and provide flexible object configurations and behaviors.
- **Behavioral Patterns:** Implement behavioral design patterns (e.g., Observer, Strategy, Command) to define communication patterns between objects, encapsulate algorithms, and manage object interactions and responsibilities.

### SOLID Principles:
- **Single Responsibility Principle (SRP):** Ensure that each class or module has a single responsibility or reason to change, promoting high cohesion and modularity in software design.
- **Open/Closed Principle (OCP):** Design classes and modules to be open for extension but closed for modification, enabling software components to be extended and customized without altering existing code.
- **Liskov Substitution Principle (LSP):** Maintain substitutability between objects of derived classes and objects of base classes, ensuring that derived classes can be used interchangeably with base class instances without affecting program correctness.
- **Interface Segregation Principle (ISP):** Define specific and minimal interfaces for clients, avoiding "fat" or monolithic interfaces, and promoting interface segregation and dependency inversion.
- **Dependency Inversion Principle (DIP):** Depend on abstractions or interfaces rather than concrete implementations, decoupling high-level modules from low-level details and promoting loose coupling and flexibility in software design.
